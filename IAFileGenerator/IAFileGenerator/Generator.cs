using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;
using NExcel;
using Ionic.Zip;
using FreeImageAPI;

namespace MOBOT.IAFileGenerator
{
    public class Generator
    {
        #region Properties

        private string _identifier = string.Empty;
        private string _outputPath = string.Empty;
        private string _marcXmlFilePath = string.Empty;
        private string _excelFilePath = string.Empty;
        private string _imageZipFilePath = string.Empty;
        private string _accessKey = string.Empty;
        private string _secretKey = string.Empty;
        private List<string> _collections = new List<string>();
        private string _contributor = string.Empty;

        // Image format is derived from the filename of the ZIP archive containing the image files
        private string _imageFormat = string.Empty;

        // String used to hold messages generated by the image component
        private string _freeimageMessage = string.Empty;

        /// <summary>
        /// Identifier to use when naming the output files
        /// </summary>
        public string Identifier
        {
            get { return _identifier; }
        }

        /// <summary>
        /// Internet Archive collections into which to place uploaded items
        /// </summary>
        public List<string> Collections
        {
            get { return _collections; }
        }

        /// <summary>
        /// Path to the MarcXML file to use when generating the Dublin Core file
        /// </summary>
        public string MarcXmlFilePath
        {
            get { return _marcXmlFilePath; }
        }

        /// <summary>
        /// Path to the Excel file containing metadata to include in generated files
        /// </summary>
        public string ExcelFilePath
        {
            get { return _excelFilePath; }
        }

        /// <summary>
        /// Path to the ZIP archive containing JP2s or TIFs to be uploaded
        /// </summary>
        public string ImageZipFilePath
        {
            get { return _imageZipFilePath; }
        }

        /// <summary>
        /// File path into which to place the output files
        /// </summary>
        public string OutputPath
        {
            get { return _outputPath; }
        }

        /// <summary>
        /// Internet Archive access key for uploading data
        /// </summary>
        public string AccessKey
        {
            get { return _accessKey; }
        }

        /// <summary>
        /// Internet Archive secret key for uploading data
        /// </summary>
        public string SecretKey
        {
            get { return _secretKey; }
        }

        #endregion Properties

        #region Constructors and Destructors

        public Generator(string identifier, List<string> collections, 
            string imageZipFilePath, string excelFilePath, string marcXmlFilePath, string outputPath, 
            string accessKey, string secretKey)
        {
            // Initialize this object
            this._identifier = identifier;
            this._collections = collections;
            this._imageZipFilePath = imageZipFilePath;
            this._excelFilePath = excelFilePath;
            this._marcXmlFilePath = marcXmlFilePath;
            this._outputPath = outputPath;
            if (!this._outputPath.EndsWith("\\")) this._outputPath += "\\";
            this._accessKey = accessKey;
            this._secretKey = secretKey;

            // Parse the image format from the Zip file name
            // Example: File name "filename_jp2.zip" => file format "jp2"
            // Example: File name "filename_tif.zip" => file format "tif"
            int formatStart = this._imageZipFilePath.LastIndexOf("_");
            int formatEnd = this._imageZipFilePath.LastIndexOf(".");
            if ((formatStart >= 0) && (formatEnd > formatStart + 1))
            {
                this._imageFormat = this._imageZipFilePath.Substring(formatStart + 1, formatEnd - formatStart - 1);
            }

            // Wire up the event for catching messages from the image component
            FreeImageEngine.Message += new OutputMessageFunction(FreeImage_Message);
        }

        ~Generator()
        {
            FreeImageEngine.Message -= new OutputMessageFunction(FreeImage_Message);
        }

        #endregion Constructors and Destructors

        #region File Generation Operations

        /// <summary>
        /// Generate all of the metadata files.  
        /// </summary>
        /// <returns>True if files generated successfully, false otherwise</returns>
        public bool Generate()
        {
            bool success = false;
            success = this.GenerateUploadFile();
            if (success) success = this.GenerateDCMetadataFile();
            if (success) success = this.GenerateScandataFile();
            return success;
        }

        #region DCMetadata events

        public event DCMetadataStartEventHandler DCMetadataStart;
        protected virtual void OnDCMetadataStart(DCMetadataStartEventArgs e)
        {
            if (DCMetadataStart != null) DCMetadataStart(this, e);
        }
        public event DCMetadataEndEventHandler DCMetadataEnd;
        protected virtual void OnDCMetadataEnd(DCMetadataEndEventArgs e)
        {
            if (DCMetadataEnd != null) DCMetadataEnd(this, e);
        }

        #endregion DCMetadata events

        /// <summary>
        ///  Produce a Dublin Core metadata file from a MARCXML file
        /// </summary>
        /// <returns>True if file generated successfully, otherwise false</returns>
        private bool GenerateDCMetadataFile()
        {
            this.LogMessage("Starting DCMetadata generation for " + this.MarcXmlFilePath);

            DCMetadataStartEventArgs e1 = new DCMetadataStartEventArgs();
            OnDCMetadataStart(e1);

            try
            {
                if (this.MarcXmlFilePath == string.Empty) throw new Exception("No MARCXML file path specified.");

                // Use a stylesheet to transform the MARCXML to Dublin Core
                StringWriter sw = new StringWriter();
                XmlWriterSettings settings = new XmlWriterSettings();
                settings.OmitXmlDeclaration = true;
                settings.Indent = true;
                XmlWriter xml = XmlWriter.Create(sw, settings);

                System.Xml.Xsl.XslCompiledTransform xsl = new System.Xml.Xsl.XslCompiledTransform();
                xsl.Load(AppDomain.CurrentDomain.BaseDirectory + "MARC21slim2OAIDC.xsl");
                xsl.Transform(this.MarcXmlFilePath, xml);

                // Add the contributor information to the DC file
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.LoadXml("<?xml version=\"1.0\"?>\r\n" + sw.ToString());
                XmlNode root = xmlDoc.DocumentElement;
                XmlNode contributor = xmlDoc.CreateElement("dc", "contributor", "http://purl.org/dc/elements/1.1/");
                contributor.InnerText = _contributor;
                root.AppendChild(contributor);

                string outputFile = this._outputPath + this._identifier + "_dc.xml";
                xmlDoc.Save(outputFile);

                // Move the MARC XML file to the output folder
                File.Move(this.MarcXmlFilePath, OutputPath + Path.GetFileName(this.MarcXmlFilePath));

                this.LogMessage("DCMetadata for " + this.MarcXmlFilePath + " written to " + outputFile);

                DCMetadataEndEventArgs e2 = new DCMetadataEndEventArgs();
                OnDCMetadataEnd(e2);

                return true;
            }
            catch (Exception ex)
            {
                this.LogError("Error generating DCMetadata for " + this.MarcXmlFilePath, ex);
                return false;
            }
        }

        #region Scandata events

        public event ScandataStartEventHandler ScandataStart;
        protected virtual void OnScandataStart(ScandataStartEventArgs e)
        {
            if (ScandataStart != null) ScandataStart(this, e);
        }
        public event ImageProcessedEventHandler ImageProcessed;
        protected virtual void OnImageProcessed(ImageProcessedEventArgs e)
        {
            if (ImageProcessed != null) ImageProcessed(this, e);
        }
        public event ScandataEndEventHandler ScandataEnd;
        protected virtual void OnScandataEnd(ScandataEndEventArgs e)
        {
            if (ScandataEnd != null) ScandataEnd(this, e);
        }

        #endregion Scandata events

        /// <summary>
        /// Produce a _scandata.xml file from an Excel file
        /// </summary>
        /// <returns>True if file generated successfully, otherwise false</returns>
        private bool GenerateScandataFile()
        {
            this.LogMessage("Starting Scandata generation for " + this.ExcelFilePath);

            ScandataStartEventArgs e1 = new ScandataStartEventArgs();
            OnScandataStart(e1);

            Workbook wb = null;

            try
            {
                if (this.ExcelFilePath == string.Empty) throw new Exception("No Excel file path specified.");
                if (ImageZipFilePath == string.Empty) throw new Exception("No image ZIP file path specified.");

                // Open the Excel file
                wb = Workbook.getWorkbook(this.ExcelFilePath);

                // Remove any pre-existing scandata file
                string outputFile = this._outputPath + this._identifier + "_scandata.xml";
                if (File.Exists(outputFile)) File.Delete(outputFile);

                List<PageData> pages = new List<PageData>();

                // Collect the data from each row in the "Page" sheet of the workbook
                foreach (Sheet sheet in wb.Sheets)
                {
                    if (sheet.Name == "Page")
                    {
                        // Start at the first row containing data (row index = 4)
                        for (int irow = 4; irow < sheet.Rows; irow++)
                        {
                            // Check if we've reached the last row
                            if (sheet.getCell(1, irow).Contents == "NaN") break;

                            // for each column
                            PageData pageData = new PageData();
                            pageData.FileName = sheet.getCell(1, irow).Contents;
                            pageData.Sequence = sheet.getCell(2, irow).Contents;
                            pageData.PagePrefix = sheet.getCell(3, irow).Contents;
                            pageData.PageNumber = sheet.getCell(4, irow).Contents;
                            pageData.ImpliedPageNumber = sheet.getCell(5, irow).Contents;
                            pageData.PageType = sheet.getCell(6, irow).Contents;
                            pageData.Year = sheet.getCell(7, irow).Contents;
                            pageData.Volume = sheet.getCell(8, irow).Contents;
                            pageData.IssuePrefix = sheet.getCell(9, irow).Contents;
                            pageData.Issue = sheet.getCell(10, irow).Contents;
                            pageData.DateCreated = sheet.getCell(11, irow).Contents;
                            pageData.DateModified = sheet.getCell(12, irow).Contents;

                            pages.Add(pageData);
                        }
                    }
                }

                // Write the page data to a new scandata.xml file
                this.WriteScandata(outputFile, pages);

                // Move the image zip file to the output folder
                File.Move(ImageZipFilePath, OutputPath + Path.GetFileName(ImageZipFilePath));

                this.LogMessage("Scandata for " + this.ExcelFilePath + " written to " + outputFile);

                ScandataEndEventArgs e2 = new ScandataEndEventArgs();
                OnScandataEnd(e2);

                return true;
            }
            catch (Exception ex)
            {
                this.LogError("Error generating Scandata for " + this.ExcelFilePath, ex);
                return false;
            }
            finally
            {
                if (wb != null) wb.close();
            }
        }

        /// <summary>
        /// Write the contents of a list of PageData objects into the specified output file.
        /// The format of the output file is the IA _scandata.xml file format.
        /// </summary>
        /// <param name="outputFile">The file path to which to write the file</param>
        /// <param name="pages">The list of PageData objects</param>
        private void WriteScandata(string outputFile, List<PageData> pages)
        {
            string scandataTemplate = File.ReadAllText(AppDomain.CurrentDomain.BaseDirectory + "scandata_template.xml");
            string pageTemplate = File.ReadAllText(AppDomain.CurrentDomain.BaseDirectory + "scandata_page_template.xml");
            string pageNumTemplate = File.ReadAllText(AppDomain.CurrentDomain.BaseDirectory + "scandata_pagenumdata_template.xml");
            string assertionTemplate = File.ReadAllText(AppDomain.CurrentDomain.BaseDirectory + "scandata_assertion_template.xml");
            StringBuilder sbPageData = new StringBuilder();
            StringBuilder sbPageNumData = new StringBuilder();
            string dpi = string.Empty;

            int leafNum = 1;
            bool assertionStarted = false;
            string startPageNum = string.Empty;
            string endPageNum = string.Empty;
            foreach (PageData pageData in pages)
            {
                // Get the image dimensions for this page
                string pageWidth = "0";
                string pageHeight = "0";
                this.GetImageDimensions(pageData.FileName, out pageWidth, out pageHeight, out dpi);

                // Set the page type (make sure we use valid IA values)
                string pageType = string.Empty;
                switch (pageData.PageType.ToLower())
                {
                    case "table of contents":
                        {
                            pageType = "Contents";
                            break;
                        }
                    case "title page":
                        {
                            pageType = "Title";
                            break;
                        }
                    default:
                        {
                            pageType = pageData.PageType;
                            break;
                        }
                }

                // Set the page number and book start elements
                string bookStart = string.Empty;
                if (leafNum == 1) bookStart = "\n      <bookStart>true</bookStart>";

                string pageNumber = string.Empty;
                if (!string.IsNullOrEmpty(pageData.PageNumber) || !string.IsNullOrEmpty(pageData.ImpliedPageNumber))
                {


                    // Example of prefix and implied page: http://www.archive.org/download/mobot31753003649016/mobot31753003649016_scandata.xml
                    if (!string.IsNullOrEmpty(pageData.PagePrefix) || !string.IsNullOrEmpty(pageData.ImpliedPageNumber)) 
                    {
                        string impliedAttr = string.Empty;
                        string altNum = pageData.PageNumber;
                        string prefix = string.Empty;

                        if (!string.IsNullOrEmpty(pageData.PagePrefix)) prefix = "prefix=\"" + pageData.PagePrefix + "\" ";
                        if (!string.IsNullOrEmpty(pageData.ImpliedPageNumber)) 
                        {
                            impliedAttr = "implied=\"1\" ";
                            altNum = pageData.ImpliedPageNumber;
                        }

                        pageNumber += "\n      <altPageNumbers>";
                        pageNumber += "\n         <altPageNumber " + impliedAttr + prefix + ">" + altNum + "</altPageNumber>";
                        pageNumber += "\n      </altPageNumbers>";
                    }

                    if (!string.IsNullOrEmpty(pageData.PageNumber))
                    {
                        pageNumber += "\n      <pageNumber>" + pageData.PageNumber + "</pageNumber>";
                        endPageNum = pageData.PageNumber;

                        // If no assertion pair has been started, write the first one with the current page number
                        if (!assertionStarted)
                        {
                            assertionStarted = true;
                            sbPageNumData.Append(String.Format(assertionTemplate, leafNum.ToString(), pageData.PageNumber));
                        }
                    }
                }
                else if (assertionStarted)
                {
                    // If an assertion pair has been started, then write the second one with the previous page number
                    assertionStarted = false;
                    sbPageNumData.Append(String.Format(assertionTemplate, (leafNum - 1).ToString(), endPageNum));
                }

                // Add the page to the complete page data string
                sbPageData.Append(String.Format(pageTemplate, leafNum.ToString(), pageType, pageWidth,
                    pageHeight, pageWidth, pageHeight, bookStart, pageNumber));

                ImageProcessedEventArgs e = new ImageProcessedEventArgs(pages.Count);
                OnImageProcessed(e);

                leafNum++;
            }

            // Write the completed scandata file
            File.WriteAllText(outputFile,
                String.Format(scandataTemplate, 
                    this._identifier, 
                    pages.Count.ToString(), 
                    dpi, 
                    String.Format(pageNumTemplate, sbPageNumData.ToString()), 
                    sbPageData.ToString()));
        }

        #region Upload events

        public event UploadStartEventHandler UploadStart;
        protected virtual void OnUploadStart(UploadStartEventArgs e)
        {
            if (UploadStart != null) UploadStart(this, e);
        }
        public event UploadEndEventHandler UploadEnd;
        protected virtual void OnUploadEnd(UploadEndEventArgs e)
        {
            if (UploadEnd != null) UploadEnd(this, e);
        }

        #endregion Upload events

        /// <summary>
        /// Produce a config file for use in uploading the data with the cURL utility
        /// </summary>
        /// <returns>True if file generated successfully, otherwise false</returns>
        private bool GenerateUploadFile()
        {
            this.LogMessage("Starting upload file generation for " + this.Identifier + " using " + this.ExcelFilePath);

            UploadStartEventArgs e1 = new UploadStartEventArgs();
            OnUploadStart(e1);

            Workbook wb = null;

            try
            {
                if (this.ExcelFilePath == string.Empty) throw new Exception("No Excel file path specified.");

                // Open the Excel file
                wb = Workbook.getWorkbook(this.ExcelFilePath);

                // Remove any pre-existing upload file
                string outputFile = this._outputPath + "upload_" + this._identifier + ".bat";
                if (File.Exists(outputFile)) File.Delete(outputFile);

                // Read the data from the workbook
                string type = string.Empty;
                string title = string.Empty;
                string publisher = string.Empty;
                string publisherPlace = string.Empty;
                string description = string.Empty;
                string date = string.Empty;
                string callNumber = string.Empty;
                List<string> creators = new List<string>();
                List<string> subjects = new List<string>();
                string sponsor = string.Empty;
                string volume = string.Empty;
                string language = string.Empty;
                string possibleCopyrightStatus = string.Empty;
                string rights = string.Empty;
                string licenseUrl = string.Empty;

                foreach (Sheet sheet in wb.Sheets)
                {
                    switch (sheet.Name)
                    {
                        case "Title":
                            type = sheet.getCell(4, 1).Contents;
                            title = sheet.getCell(4, 3).Contents;
                            publisher = sheet.getCell(4, 8).Contents;
                            publisherPlace = sheet.getCell(4, 7).Contents;
                            description = sheet.getCell(4, 6).Contents;
                            callNumber = sheet.getCell(4, 17).Contents;
                            language = sheet.getCell(4, 19).Contents;
                            if (type == "Monograph" || type == "Other") date = sheet.getCell(4, 12).Contents;
                            for (int icol = 4; icol < 13; icol++)
                            {
                                string subject = sheet.getCell(icol, 18).Contents;
                                if (!string.IsNullOrEmpty(subject)) subjects.Add(subject);
                            }
                            break;
                        case "Creator":
                            for (int irow = 4; irow < sheet.Rows; irow++)
                            {
                                if (string.IsNullOrEmpty(sheet.getCell(1, irow).Contents)) break;
                                creators.Add(sheet.getCell(1, irow).Contents);
                            }
                            break;
                        case "Item":
                            _contributor = sheet.getCell(4, 10).Contents;
                            sponsor = sheet.getCell(4, 11).Contents;
                            volume = sheet.getCell(4, 4).Contents;
                            if (type == "Serial") date = sheet.getCell(4, 6).Contents;
                            if (!string.IsNullOrEmpty(sheet.getCell(4, 8).Contents))
                            {
                                // If specified, item language overrides title language
                                language = sheet.getCell(4, 8).Contents;
                            }
                            break;
                        case "Rights":
                            possibleCopyrightStatus = sheet.getCell(4, 1).Contents;
                            rights = sheet.getCell(4, 2).Contents;
                            licenseUrl = sheet.getCell(4, 4).Contents;
                            break;
                    }
                }

                // Build the "header" lines for any optional information to go into the output file
                StringBuilder otherHeaders = new StringBuilder();
                int metaIndex = 1;
                foreach (string collection in this.Collections)
                {
                    otherHeaders.Append("--header \"x-archive-meta" + GetMetaIndexString(metaIndex) + "-collection:" + collection + "\" ");
                    metaIndex++;
                }
                if (!string.IsNullOrEmpty(volume)) otherHeaders.Append("--header \"x-archive-meta-volume:" + EncodeHeader(volume) + "\" ");
                metaIndex = 1;
                foreach (string creator in creators)
                {
                    otherHeaders.Append("--header \"x-archive-meta" + GetMetaIndexString(metaIndex) + "-creator:" + EncodeHeader(creator) + "\" ");
                    metaIndex++;
                }
                metaIndex = 1;
                foreach (string subject in subjects)
                {
                    otherHeaders.Append("--header \"x-archive-meta" + GetMetaIndexString(metaIndex) + "-subject:" + EncodeHeader(subject) + "\" ");
                    metaIndex++;
                }
                if (!string.IsNullOrEmpty(description)) otherHeaders.Append("--header \"x-archive-meta-description:" + EncodeHeader(description) + "\" ");
                if (!string.IsNullOrEmpty(publisher) || !string.IsNullOrEmpty(publisherPlace))
                {
                    otherHeaders.Append("--header \"x-archive-meta-publisher:" +
                       EncodeHeader(((publisherPlace ?? string.Empty) + " " + (publisher ?? string.Empty)).Trim()) + "\" ");
                }
                if (!string.IsNullOrEmpty(date)) otherHeaders.Append("--header \"x-archive-meta-date:" + date + "\" ");
                if (!string.IsNullOrEmpty(language)) otherHeaders.Append("--header \"x-archive-meta-language:" + language + "\" ");
                if (!string.IsNullOrEmpty(callNumber)) otherHeaders.Append("--header \"x-archive-meta-call_number:" + EncodeHeader(callNumber) + "\" ");
                if (!string.IsNullOrEmpty(possibleCopyrightStatus)) otherHeaders.Append("--header \"x-archive-meta-possible-copyright-status:" + possibleCopyrightStatus + "\" ");
                if (!string.IsNullOrEmpty(rights)) otherHeaders.Append("--header \"x-archive-meta-rights:" + rights + "\" ");
                if (!string.IsNullOrEmpty(licenseUrl)) otherHeaders.Append("--header \"x-archive-meta-licenseurl:" + licenseUrl + "\" ");

                // Write the upload file
                string outputTemplate = File.ReadAllText(AppDomain.CurrentDomain.BaseDirectory + "upload_template.txt");
                outputTemplate = outputTemplate.Replace("<curlpath>", AppDomain.CurrentDomain.BaseDirectory);
                outputTemplate = outputTemplate.Replace("<accesskey>", this.AccessKey);
                outputTemplate = outputTemplate.Replace("<secretkey>", this.SecretKey);
                outputTemplate = outputTemplate.Replace("<sponsor>", EncodeHeader(sponsor));
                outputTemplate = outputTemplate.Replace("<contributor>", EncodeHeader(_contributor));
                outputTemplate = outputTemplate.Replace("<title>", EncodeHeader(title));
                outputTemplate = outputTemplate.Replace("<curationdate>", DateTime.Now.ToString("yyyyMMddhhmmss"));
                outputTemplate = outputTemplate.Replace("<iaidentifier>", this.Identifier);
                outputTemplate = outputTemplate.Replace("<imagezipfile>", this.OutputPath + Path.GetFileName(this.ImageZipFilePath));
                outputTemplate = outputTemplate.Replace("<imageformat>", this._imageFormat);
                outputTemplate = outputTemplate.Replace("<marcfile>", this.OutputPath + Path.GetFileName(this.MarcXmlFilePath));
                outputTemplate = outputTemplate.Replace("<dcfile>", this.OutputPath + this.Identifier + "_dc.xml");
                outputTemplate = outputTemplate.Replace("<scandatafile>", this.OutputPath + this.Identifier + "_scandata.xml");
                outputTemplate = outputTemplate.Replace("<otherheaders>", otherHeaders.ToString());
                File.WriteAllText(outputFile, outputTemplate);

                this.LogMessage("Upload file for " + this.Identifier + " written using " + this.ExcelFilePath + " to " + outputFile);

                UploadEndEventArgs e2 = new UploadEndEventArgs();
                OnUploadEnd(e2);

                return true;
            }
            catch (Exception ex)
            {
                this.LogError("Error generating upload file for " + this.Identifier + " using " + this.ExcelFilePath, ex);
                return false;
            }
            finally
            {
                if (wb != null) wb.close();
            }
        }

        /// <summary>
        /// Get a formatted index value for an IA S3 header value.
        /// For example, transform integer 1 to string "01", int 2 to string "02", ect.
        /// </summary>
        /// <param name="metaIndex"></param>
        /// <returns></returns>
        private string GetMetaIndexString(int metaIndex)
        {
            string metaIndexStr = "0" + metaIndex.ToString();
            return metaIndexStr.Substring(metaIndexStr.Length - 2);
        }

        private string EncodeHeader(string header)
        {
            header = string.IsNullOrEmpty(header) ? string.Empty : string.Format("uri({0})", System.Web.HttpUtility.UrlEncode(header));
            return header;
        }

        #endregion File Generation Operations

        #region Image Operations

        /// <summary>
        /// Get the image dimensions for the specific file
        /// </summary>
        /// <remarks>
        /// This method makes use of two external libraries: 
        /// 
        ///     DotNetZip (http://dotnetzip.codeplex.com/)
        ///     FreeImage (http://freeimage.sourceforge.net/)
        ///     
        /// These libraries are used to extract the image files from their ZIP packages (DotNetZip)
        /// and read the dimensions of the images (FreeImage).
        /// </remarks>
        /// <param name="fileName"></param>
        /// <param name="width"></param>
        /// <param name="height"></param>
        private void GetImageDimensions(string fileName, out string width, out string height, out string dpi)
        {
            width = "0";
            height = "0";
            dpi = "0";

            // Get the image from the ZIP file
            string tempFolder = this.OutputPath + "TEMP";
            Directory.CreateDirectory(tempFolder);

            bool imageFound = false;
            string embeddedFileName = this.Identifier + "_" + this._imageFormat + "/" + fileName;
            using (ZipFile zip = ZipFile.Read(this.ImageZipFilePath))
            {
                // Extract the appropriate image
                foreach (ZipEntry e in zip)
                {
                    if (e.FileName.ToLower() == embeddedFileName.ToLower())
                    {
                        e.Extract(tempFolder, ExtractExistingFileAction.OverwriteSilently);
                        imageFound = true;
                        break;
                    }
                }
            }

            // Read the width and height of the image
            if (imageFound)
            {
                // Image format is stored in 'format' on successful load.
                FREE_IMAGE_FORMAT format = FREE_IMAGE_FORMAT.FIF_UNKNOWN;

                // Loading the image
                string imageFileName = tempFolder + "\\" + embeddedFileName.Replace("/", "\\");
                FIBITMAP dib = FreeImage.LoadEx(imageFileName, ref format);

                try
                {
                    if (dib.IsNull)
                    {
                        this.LogMessage("Image could not be loaded.");
                        // Check whether FreeImage generated an error message
                        if (this._freeimageMessage != string.Empty) this.LogMessage("FreeImage Error: " + this._freeimageMessage);
                        return;
                    }

                    // Read width and height
                    width = FreeImage.GetWidth(dib).ToString();
                    height = FreeImage.GetHeight(dib).ToString();

                    // Read the Dots-Per-Inch
                    dpi = FreeImage.GetResolutionX(dib).ToString();

                    // Read file format (possibly useful somewhere else?)
                    //string lFormat = String.Format("File Format: {0}", FreeImage.GetFormatFromFIF(format));
                }
                finally
                {
                    FreeImage.UnloadEx(ref dib);
                }

            }

            // Clean up the extracted image and temp folder
            Directory.Delete(tempFolder, true);
        }

        /// <summary>
        /// FreeImage calls this method when it generates messages
        /// </summary>
        /// <param name="fif"></param>
        /// <param name="message"></param>
        void FreeImage_Message(FREE_IMAGE_FORMAT fif, string message)
        {
            if (this._freeimageMessage == string.Empty)
            {
                this._freeimageMessage = message;
            }
            else
            {
                this._freeimageMessage += "\n" + message;
            }
        }

        #endregion Image Operations

        #region Logging Operations

        private void LogMessage(string message)
        {
            DateTime now = System.DateTime.Now;
            message = now.ToShortDateString() + " " + now.ToLongTimeString() + "\t" + message + "\r\n";
            File.AppendAllText(AppDomain.CurrentDomain.BaseDirectory + "IAFileGenerator.Log", message, Encoding.UTF8);
        }

        private void LogError(string message, Exception ex)
        {
            StringBuilder sb = new StringBuilder();

            if (message != string.Empty) sb.Append(message + "\r\n");
            sb.Append("Source: " + ex.Source + "\r\n");
            sb.Append("Error Message: " + ex.Message + "\r\n");
            sb.Append("Stack Trace: " + ex.StackTrace + "\r\n");
            sb.Append("\r\n");

            this.LogMessage(sb.ToString());
        }

        static public string GetLogText()
        {
            string logFileName = AppDomain.CurrentDomain.BaseDirectory + "IAFileGenerator.Log";
            if (File.Exists(logFileName))
            {
                return File.ReadAllText(logFileName);
            }
            else
            {
                return string.Empty;
            }
        }

        #endregion Logging Operations
    }

    #region File generation event arguments and delegates

    public class DCMetadataStartEventArgs : EventArgs { }
    public class DCMetadataEndEventArgs : EventArgs { }
    public class ScandataStartEventArgs : EventArgs { }
    public class ImageProcessedEventArgs : EventArgs
    {
        private int _maxImages = 1;
        public int MaxImages { get { return _maxImages; } }
        public ImageProcessedEventArgs(int maxImages) { _maxImages = maxImages; }    
    }
    public class ScandataEndEventArgs : EventArgs { }
    public class UploadStartEventArgs : EventArgs { }
    public class UploadEndEventArgs : EventArgs { }

    public delegate void DCMetadataStartEventHandler(object sender, DCMetadataStartEventArgs e);
    public delegate void DCMetadataEndEventHandler(object sender, DCMetadataEndEventArgs e);
    public delegate void ScandataStartEventHandler(object sender, ScandataStartEventArgs e);
    public delegate void ImageProcessedEventHandler(object sender, ImageProcessedEventArgs e);
    public delegate void ScandataEndEventHandler(object sender, ScandataEndEventArgs e);
    public delegate void UploadStartEventHandler(object sender, UploadStartEventArgs e);
    public delegate void UploadEndEventHandler(object sender, UploadEndEventArgs e);

    #endregion File generation event arguments and delegates
}
